Project Implementation Report: Kerala Quest

Version: 1.0

Date: October 26, 2023

Target Region: Kerala, India (Calicut, Kochi, Trivandrum)

1. Executive Summary

Kerala Quest is a location-based Augmented Reality (AR) and social role-playing game designed to promote tourism and social interaction in Kerala's famous hotspots. The application features three distinct user roles (Player, Volunteer, Admin) and relies heavily on geolocation, real-time communication, and gamification mechanics.

This report outlines the technical architecture, security measures, and implementation roadmap required to build a secure, scalable production version of the prototype.

2. Technical Architecture & Stack Recommendation

To ensure the app works smoothly outdoors (mobile data) and handles real-time location updates, we recommend a Hybrid or Native Mobile Architecture.

A. Frontend (Mobile App)

Recommended: Flutter (Dart) or React Native.

Why: You need native access to GPS, Camera (for QR scanning), and Accelerometer (for mini-games like "Coconut Catch"). These frameworks offer near-native performance on both Android and iOS from a single codebase.

Alternative (Web-First): Next.js (React) + PWA (Progressive Web App).

Why: Lower barrier to entry (no app store download needed), but has limitations with background geolocation and AR features.

B. Backend (Server & API)

Recommended: Node.js with NestJS or Go (Golang).

Why: Node.js handles real-time concurrency (websockets for chat/location) extremely well. Go is excellent for high-performance location processing if the user base grows large.

C. Database (The Core)

Primary DB: PostgreSQL with PostGIS extension.

Critical: Standard SQL databases cannot efficiently query "users within 500 meters." PostGIS is the industry standard for geospatial queries.

Real-time DB: Redis or Firebase Realtime Database.

Usage: Storing transient data like "current player location" for the live Admin Heatmap and "Chat" messages.

D. Mapping & Geolocation

Map Provider: Mapbox (Recommended) or Google Maps Platform.

Why: Mapbox allows for complete custom styling (removing highway clutter, highlighting game zones) which is essential for the "Game Map" aesthetic seen in the prototype.

3. Security Architecture (The "Most Secured Platform")

Building a social, location-based app requires distinct security layers to protect users physically and digitally.

A. Location Privacy & Safety (Crucial)

Location Fuzzing: Never broadcast a player's exact coordinates to strangers.

Implementation: If Player A is at [11.2588, 75.7804], the server should send [11.2590, 75.7800] (a random point within 50-100m) to Player B. Exact location is only for the server and the user themselves.

Ghost Mode: Allow users to toggle "Invisible Mode" instantly (as seen in the prototype design).

Geofencing: Restrict "Mingle" features to verified public zones (e.g., Calicut Beach Promenade) and disable them automatically if a user strays into secluded areas.

B. Data Security

Encryption: * TLS 1.3 for all data in transit.

AES-256 for sensitive data at rest (PII, Chat logs).

Authentication: Use OAuth 2.0 (Google/Apple Sign-in) combined with JWT (JSON Web Tokens) for session management. Avoid storing passwords directly.

C. Anti-Cheat (Game Integrity)

GPS Spoofing Detection: Users will try to fake their location to solve quests without traveling.

Solution: Analyze altitude data, speed of movement (teleporting is impossible), and verify against cellular tower triangulation (on native Android/iOS).

QR Tokenization: For Volunteer scanning, QR codes should be dynamic (regenerating every 30 seconds) rather than static images, preventing screenshots from being shared.

4. Module Breakdown & Implementation Details

Module 1: The Player (Explorer)

Geospatial Triggers: The app must "wake up" when entering a hotspot (Geofence entry event).

AR Integration: Use AR.js (Web) or ARKit/ARCore (Native) for the "Halwa Run" or "Catch" games.

Social Graph: Use a Graph Database (like Neo4j) or efficient SQL relations to manage "Friend" vs "Stranger" connections.

Module 2: The Volunteer (Ops)

QR Scanner: Native camera implementation.

Task Queue: A simple ticketing system (WebSocket based) where the Admin pushes tasks ("Check Crowd at South Pier") and Volunteers accept/complete them.

Module 3: The Admin (God Mode)

Live Heatmap: Use WebSockets (Socket.io) to stream aggregated location points. Do not plot individual user dots for privacy; plot "density clusters."

Emergency Broadcast: A high-priority push notification channel (FCM/APNS) to alert all users in a specific geofence (e.g., "High Tide warning at Beach").

5. Development Roadmap

Phase 1: The MVP (Minimum Viable Product)

Tech: React PWA + Firebase.

Features: Login, GPS location display, Simple Text Riddles (Manual input), Admin Dashboard (Basic).

Goal: Test at Calicut Beach with 50 users to verify game mechanics.

Phase 2: The "Kerala Quest" App (Production)

Tech: Migrate to Flutter + Node.js/PostGIS.

Features: Real-time Chat, Volunteer QR Scanning, Dynamic Map Layers, Inventory System.

Security: Implement Location Fuzzing and GPS Spoofing detection.

Phase 3: Social & Scale

Features: AR Mini-games, Guilds/Teams, Leaderboards per District.

Infrastructure: Kubernetes scaling for handling thousands of concurrent connections during festivals (e.g., Onam, Thrissur Pooram).

6. Regulatory Compliance (India)

DPDP Act 2023 (Digital Personal Data Protection Act): * You must obtain explicit consent for location tracking.

You must provide a "Right to be Forgotten" (Delete Account & Data).

Server Location: Hosting user data within India (e.g., AWS Mumbai region or Google Cloud Delhi) is highly recommended for latency and compliance.

7. Recommended Third-Party Services

Auth: Firebase Auth or Auth0.

Maps: Mapbox (Better styling) or Google Maps.

Push Notifications: OneSignal.

Payment (if selling items): Razorpay (Best integration for India UPI).


8. Beginner's Execution Guide (Zero to Hero)

Since you are a beginner, jumping straight into complex frameworks like Flutter or Node.js might be overwhelming. Here is a simplified, step-by-step path to build the MVP using HTML/JS (Frontend) and Firebase (Backend). This stack is beginner-friendly, free to start, and powerful enough for your first 100 users.

Step 1: Set Up Your Tools

Before writing code, you need the right environment.

Download VS Code: This is the industry-standard code editor.

Install Live Server Extension: In VS Code, install "Live Server" to view your HTML changes instantly.

Create a Folder: Name it kerala-quest. Inside, create index.html, style.css, and app.js.

Step 2: Build the Visuals (Frontend)

Copy the Prototype: Take the HTML/CSS code provided in our earlier conversation and paste it into your files.

Customize: Change the colors to match your vision. Try adding a new location (e.g., "Fort Kochi") to the LOCATIONS array in the JavaScript code to understand how the data works.

Test: Open index.html with Live Server and make sure it looks good on your mobile phone (you can access your computer's local server IP on your phone if they are on the same WiFi).

Step 3: Add the "Brain" (Firebase Backend)

Currently, your prototype forgets everything when you refresh. You need a database. Firebase by Google is the best choice for beginners.

Go to Firebase Console: Create a new project called "Kerala Quest".

Enable Authentication: Turn on "Email/Password" or "Google Sign-in" in the Build > Authentication tab.

Enable Firestore Database: Create a database. Start in "Test Mode".

Structure: Create a collection called users.

Connect Your App: * In Project Settings, scroll down to "Your apps" -> select Web (</> icon).

Copy the firebaseConfig code block.

Paste it at the top of your app.js file (or a separate firebase-config.js).

Step 4: Make It Real-Time

Now, replace the "Mock Data" in your JavaScript with real database calls.

Saving Location: When a player logs in, use navigator.geolocation.getCurrentPosition to get their GPS.

Code Logic: setDoc(doc(db, "users", userId), { lat: myLat, lng: myLng })

Reading Locations: To see other players, use a "Snapshot Listener".

Code Logic: onSnapshot(collection(db, "users"), (snapshot) => { ...update map... })

Why: This function runs automatically whenever anyone else moves or joins! This creates that "live game" feeling without complex code.

Step 5: Hosting (Deploying to the Internet)

You can't ask people to come to the beach and play if the code is only on your laptop.

Use Vercel or Netlify: These are free hosting services.

Drag and Drop: Simply drag your kerala-quest folder into the Netlify dashboard.

Get a URL: In seconds, you will get a link like kerala-quest.netlify.app. Send this to your friends!

Step 6: Testing in the Field (Calicut Beach)

The "Sunlight" Test: Go to the actual location. Can you read the screen in bright sunlight? (You might need to increase contrast).

Network Test: Does the app work on mobile data (4G/5G)?

GPS Drift: Notice how GPS jumps around? You will need to make your game forgiving (e.g., "You are within 50m" instead of "You are exactly here").

Step 7: Iterate & Secure

Once the basic version works:

Add Rules: In Firebase, set Security Rules so players can only edit their own location, not others'.

Add Admin: Create a special boolean field isAdmin: true in your database for your account, and show the Admin Dashboard only if that is true.
